<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPS NFT Mint</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        /* Custom CSS for the 3D flip effect and card appearance */
        .perspective { perspective: 1000px; }
        .card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; }
        .card.flipped .card-inner { transform: rotateY(180deg); }
        .card-front, .card-back { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; display: flex; justify-content: center; align-items: center; border-radius: 0.5rem; /* Corresponds to Tailwind's rounded-lg */ }
        .card-front { transform: rotateY(180deg); }
        @keyframes cardAppear { from { opacity: 0; transform: scale(0.8) translateY(20px); } to { opacity: 1; transform: scale(1) translateY(0); } }
        .card-appear { animation: cardAppear 0.3s ease-out forwards; opacity: 0; }
        /* Basic loading spinner */
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 1rem auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Ensure elements don't overlap awkwardly */
        body { display: flex; flex-direction: column; }
        #app { flex-grow: 1; }
        /* Style for the div where QR code will be generated */
        #qr-code-display { width: 200px; height: 200px; margin: 0 auto; }
        #qr-code-display img { width: 100%; height: 100%; display: block; } /* Ensure generated img fits */

    </style>
</head>
<body class="bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500 min-h-screen flex flex-col justify-center items-center font-sans p-4 text-white">

    <div id="app" class="text-center w-full max-w-3xl mx-auto"> <h1 class="text-3xl font-bold mb-6">üéÆ RPS NFT Mint Game</h1>

        <div id="connection-status" class="mb-4 text-lg">
            Status: Not Connected
        </div>

        <div id="wallet-info" class="hidden mb-4 bg-black bg-opacity-20 p-3 rounded-lg">
            <p><strong>Wallet:</strong> <span id="wallet-address" class="font-mono"></span></p>
        </div>

        <button id="connect-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transform hover:scale-105 transition duration-300 ease-in-out mb-4">
            Connect Wallet
        </button>

        <div id="qr-container" class="hidden my-4 p-4 bg-white rounded-lg inline-block shadow-xl">
            <h3 class="text-black text-lg font-semibold mb-2">Scan QR with Enjin Wallet</h3>
            <div id="qr-code-display"></div>
            <p class="text-gray-600 text-sm mt-2">Waiting for connection...</p>
        </div>

        <div id="balances" class="hidden my-4 bg-black bg-opacity-20 p-4 rounded-lg">
            <h2 class="text-xl font-semibold mb-2">Your Tokens</h2>
            <div class="flex justify-around text-center">
                <div><p class="text-4xl">‚úä</p><p>Rock: <span id="rock-count" class="font-bold">0</span></p></div>
                <div><p class="text-4xl">üìÑ</p><p>Paper: <span id="paper-count" class="font-bold">0</span></p></div>
                <div><p class="text-4xl">‚úÇÔ∏è</p><p>Scissors: <span id="scissors-count" class="font-bold">0</span></p></div>
            </div>
        </div>

        <div id="progress" class="hidden my-4 bg-black bg-opacity-20 p-3 rounded-lg">
            <h2 class="text-xl font-semibold mb-1">Supply Left</h2>
            <p><span id="minted-count" class="font-bold">--</span> / 150 Total</p>
        </div>

        <button id="buy-button" class="hidden bg-yellow-400 hover:bg-yellow-500 text-gray-800 font-bold py-3 px-6 rounded-full shadow-lg transform hover:scale-105 transition duration-300 ease-in-out mb-4 disabled:opacity-50 disabled:cursor-not-allowed">
            Buy Booster Pack (10 cENJ)
        </button>

        <div id="mint-status" class="my-4 min-h-[50px]">
             <div id="mint-loader" class="loader hidden"></div>
             <p id="mint-result" class="text-xl font-semibold"></p>
        </div>


        <div id="card-container" class="hidden mt-6 flex flex-wrap justify-center gap-3 md:gap-4">
            <div class="reveal-card-item card perspective w-24 h-36 md:w-28 md:h-44 lg:w-32 lg:h-48"> <div class="card-inner shadow-xl"><div class="card-back bg-purple-600 text-white text-4xl font-bold rounded-lg flex justify-center items-center">?</div><div class="card-front bg-white text-5xl md:text-6xl rounded-lg flex justify-center items-center"></div></div></div>
            <div class="reveal-card-item card perspective w-24 h-36 md:w-28 md:h-44 lg:w-32 lg:h-48"> <div class="card-inner shadow-xl"><div class="card-back bg-purple-600 text-white text-4xl font-bold rounded-lg flex justify-center items-center">?</div><div class="card-front bg-white text-5xl md:text-6xl rounded-lg flex justify-center items-center"></div></div></div>
            <div class="reveal-card-item card perspective w-24 h-36 md:w-28 md:h-44 lg:w-32 lg:h-48"> <div class="card-inner shadow-xl"><div class="card-back bg-purple-600 text-white text-4xl font-bold rounded-lg flex justify-center items-center">?</div><div class="card-front bg-white text-5xl md:text-6xl rounded-lg flex justify-center items-center"></div></div></div>
            <div class="reveal-card-item card perspective w-24 h-36 md:w-28 md:h-44 lg:w-32 lg:h-48"> <div class="card-inner shadow-xl"><div class="card-back bg-purple-600 text-white text-4xl font-bold rounded-lg flex justify-center items-center">?</div><div class="card-front bg-white text-5xl md:text-6xl rounded-lg flex justify-center items-center"></div></div></div>
            <div class="reveal-card-item card perspective w-24 h-36 md:w-28 md:h-44 lg:w-32 lg:h-48"> <div class="card-inner shadow-xl"><div class="card-back bg-purple-600 text-white text-4xl font-bold rounded-lg flex justify-center items-center">?</div><div class="card-front bg-white text-5xl md:text-6xl rounded-lg flex justify-center items-center"></div></div></div>
        </div>

        <button id="dismiss-button" class="hidden mt-6 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg shadow transition duration-200">
            Dismiss Pack
        </button>
    </div>

    <script>
        // --- Configuration ---
        const backendUrl = "https://mint-rps-duel.onrender.com"; // Your deployed backend URL
        const pollingInterval = 3000; // Check auth status every 3 seconds
        const tokenMap = { // Map Token IDs from backend to display info
            1: { name: "Rock", emoji: "‚úä" },
            2: { name: "Paper", emoji: "üìÑ" },
            3: { name: "Scissors", emoji: "‚úÇÔ∏è" }
        };
        const cardAppearDelay = 150; // Delay between cards appearing (ms)
        const cardRevealDelay = 300; // Delay between cards flipping (ms)


        // --- State Variables ---
        let userWallet = null;
        let authTokenId = null; // Will store the Auth Session ID
        let isConnected = false;
        let pollIntervalId = null;
        let qrCodeInstance = null; // To hold the QRCode library instance

        // --- DOM Element References ---
        const connectBtn = document.getElementById("connect-btn");
        const buyButton = document.getElementById("buy-button");
        const dismissButton = document.getElementById("dismiss-button");
        const qrContainer = document.getElementById("qr-container");
        const qrCodeDisplayDiv = document.getElementById("qr-code-display"); // Div for QR code
        const connectionStatus = document.getElementById("connection-status");
        const walletInfo = document.getElementById("wallet-info");
        const walletAddressSpan = document.getElementById("wallet-address");
        const balancesDiv = document.getElementById("balances");
        const progressDiv = document.getElementById("progress");
        const rockCountSpan = document.getElementById("rock-count");
        const paperCountSpan = document.getElementById("paper-count");
        const scissorsCountSpan = document.getElementById("scissors-count");
        const mintedCountSpan = document.getElementById("minted-count");
        const mintStatusDiv = document.getElementById("mint-status");
        const mintLoader = document.getElementById("mint-loader");
        const mintResult = document.getElementById("mint-result");
        const cardContainer = document.getElementById("card-container");
        const revealCards = cardContainer.querySelectorAll('.reveal-card-item'); // Select all 5 card elements

        // --- Helper Functions ---
        function shortenAddress(address) {
            if (!address || address.length < 10) return address;
            // Extract the 0x part if it's a CAIP-10 ID
            const parts = address.split(':');
            const addr = parts[parts.length - 1];
            return `${addr.substring(0, 6)}...${addr.substring(addr.length - 4)}`;
        }
        function wait(ms) { // Added wait function for async delays
             return new Promise(resolve => setTimeout(resolve, ms));
        }


        // --- UI Update Functions ---
        function updateUI() {
            if (isConnected && userWallet) {
                connectionStatus.textContent = "Status: Connected";
                walletAddressSpan.textContent = shortenAddress(userWallet); // Use helper
                connectBtn.classList.add('hidden');
                qrContainer.classList.add('hidden'); // Hide QR when connected
                walletInfo.classList.remove('hidden');
                balancesDiv.classList.remove('hidden');
                progressDiv.classList.remove('hidden');
                buyButton.classList.remove('hidden');
                loadBalancesAndSupply(); // Load data now that we are connected
            } else {
                connectionStatus.textContent = "Status: Not Connected";
                connectBtn.classList.remove('hidden');
                connectBtn.disabled = false; // Re-enable connect button
                walletInfo.classList.add('hidden');
                balancesDiv.classList.add('hidden');
                progressDiv.classList.add('hidden');
                buyButton.classList.add('hidden');
                cardContainer.classList.add('hidden'); // Hide card if disconnected
                dismissButton.classList.add('hidden');
                 mintResult.textContent = ''; // Clear result
                 // Don't hide QR container immediately on disconnect, only if connecting
                 // qrContainer.classList.add('hidden');
            }
            // Clear loader if it was showing
            mintLoader.classList.add('hidden');
        }

        // --- Core Logic ---

        // 1. Start Connection Process
        async function connectWallet() {
            connectionStatus.textContent = "Status: Connecting...";
            connectBtn.disabled = true;
            mintResult.textContent = ''; // Clear previous results
            qrContainer.classList.add('hidden'); // Hide old QR if any

            try {
                const res = await fetch(`${backendUrl}/start-auth`);
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                const data = await res.json();

                console.log("üîë Received start-auth response:", data);

                // Expecting { id, state, authenticationUrl }
                if (!data.id || !data.authenticationUrl) {
                    throw new Error("Missing ID or authenticationUrl from backend!");
                }

                authTokenId = data.id; // Store the session ID

                // --- Generate QR Code from authenticationUrl ---
                qrCodeDisplayDiv.innerHTML = ''; // Clear previous QR code
                try {
                    // Use the QRCode library (loaded from CDN)
                    // QRCode constructor takes the DOM element (not ID) and options
                    qrCodeInstance = new QRCode(qrCodeDisplayDiv, {
                        text: data.authenticationUrl,
                        width: 200,
                        height: 200,
                        colorDark : "#000000",
                        colorLight : "#ffffff",
                        correctLevel : QRCode.CorrectLevel.H // High correction level
                    });
                    console.log("QR Code generated for:", data.authenticationUrl);
                } catch(qrError) {
                     console.error("‚ùå Failed to generate QR Code:", qrError);
                     throw new Error("Could not generate QR code.");
                }
                // --- End QR Code Generation ---

                qrContainer.classList.remove("hidden"); // Show container with new QR
                connectionStatus.textContent = "Status: Scan QR Code";

                // Start polling
                startPolling();

            } catch (err) {
                console.error("‚ùå Failed to start auth session:", err);
                connectionStatus.textContent = `Error: ${err.message}. Please try again.`;
                connectBtn.disabled = false;
                 qrContainer.classList.add("hidden"); // Hide QR on error
            }
        }

        // 2. Poll for Authentication Status
        function startPolling() {
            // Clear any existing interval
            if (pollIntervalId) clearInterval(pollIntervalId);

            console.log(`Starting polling for authSessionId: ${authTokenId}`);
            pollIntervalId = setInterval(async () => {
                if (!authTokenId) {
                    console.log("Polling stopped: No authTokenId.");
                    clearInterval(pollIntervalId);
                    return;
                }
                try {
                    // Use the correct variable name for the session ID in the URL
                    const check = await fetch(`${backendUrl}/check-auth/${authTokenId}`);
                    // Stop polling if fetch fails consistently? Maybe add a counter?
                    if (!check.ok) {
                        // 404 might be expected if session not found/linked yet
                        if (check.status !== 404) {
                           console.warn(`Polling check failed: ${check.status}`);
                        } else {
                             console.log("Polling: Auth session not found or linked yet (404).");
                        }
                        return; // Continue polling
                    }
                    const status = await check.json();

                    // console.log("üîÑ Polling status:", status); // Verbose log

                    if (status.address) {
                        // SUCCESS! Wallet Connected
                        console.log("Polling success: Wallet connected!", status.address);
                        clearInterval(pollIntervalId);
                        pollIntervalId = null;
                        userWallet = status.address; // Store the CAIP-10 address
                        isConnected = true;
                        updateUI(); // Update UI to connected state
                    }
                    // else: continue polling (address is null)
                } catch (err) {
                    console.error("‚ùå Polling error:", err);
                    // Potentially stop polling after too many errors?
                }
            }, pollingInterval);
        }

        // 3. Load Balances and Supply
        async function loadBalancesAndSupply() {
             if (!isConnected || !userWallet) return;
             console.log("Loading balances and supply...");
             try {
                 // Fetch both concurrently
                 // Pass the userWallet (CAIP-10 ID) directly to the balances endpoint
                 const [tokensRes, supplyRes] = await Promise.all([
                     fetch(`${backendUrl}/balances/${encodeURIComponent(userWallet)}`), // Ensure wallet ID is URL encoded
                     fetch(`${backendUrl}/supply`)
                 ]);

                 if (!tokensRes.ok || !supplyRes.ok) {
                     // Log detailed error if possible
                     const tokensError = !tokensRes.ok ? await tokensRes.text() : '';
                     const supplyError = !supplyRes.ok ? await supplyRes.text() : '';
                     console.error(`Fetch error: Balances=${tokensRes.status} ${tokensError}, Supply=${supplyRes.status} ${supplyError}`);
                     throw new Error("Failed to fetch balances or supply");
                 }

                 const tokens = await tokensRes.json();
                 const supply = await supplyRes.json();

                 console.log("Balances:", tokens, "Supply:", supply);

                 // Update UI - Use tokenMap IDs
                 rockCountSpan.textContent = tokens["1"] || 0;
                 paperCountSpan.textContent = tokens["2"] || 0;
                 scissorsCountSpan.textContent = tokens["3"] || 0;

                 const totalMinted = 150 - (supply.remaining || 0); // Calculate minted based on remaining
                 mintedCountSpan.textContent = totalMinted;

                 // Disable mint button if sold out
                 if (supply.remaining <= 0) { // Check if less than or equal to 0
                     buyButton.disabled = true;
                     buyButton.textContent = "Sold Out";
                 } else {
                     buyButton.disabled = false;
                      buyButton.textContent = "Buy Booster Pack (10 cENJ)";
                 }

             } catch (err) {
                 console.error("‚ùå Error loading balances/supply:", err);
                 mintResult.textContent = "Error loading game data.";
             }
        }

        // 4. Buy Booster / Mint Token
        async function buyPack() {
            // Use authTokenId (which holds the session ID)
            if (!isConnected || !authTokenId) { mintResult.textContent = "Error: Not connected properly."; return; }
            console.log("üöÄ Initiating mint process...");
            buyButton.disabled = true;
            mintLoader.classList.remove('hidden');
            mintResult.textContent = 'Minting... Please approve payment in wallet.';
            cardContainer.classList.add('hidden');
            dismissButton.classList.add('hidden');
            resetCardsState();
            try {
                const res = await fetch(`${backendUrl}/mint`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ authTokenId }) }); // Send session ID
                if (!res.ok) { let errorMsg = `Mint request failed! Status: ${res.status}`; try { const errorData = await res.json(); errorMsg = errorData.details || errorData.error || errorMsg; } catch (e) { /* Ignore */ } throw new Error(errorMsg); }
                const result = await res.json();
                console.log("‚úÖ Mint successful:", result);
                if (result.success && Array.isArray(result.mintedTokens) && result.mintedTokens.length > 0) {
                    mintResult.textContent = `Success! Opened a pack!`;
                    revealMultipleCards(result.mintedTokens);
                    // Wait a short moment for blockchain update before reloading balances
                    await wait(2000);
                    loadBalancesAndSupply();
                } else { throw new Error(result.details || result.error || "Mint failed: Invalid response from server."); }
            } catch (err) { console.error("‚ùå Minting error:", err); mintResult.textContent = `Error: ${err.message}`; loadBalancesAndSupply(); } // Reload supply info even on error
            finally { mintLoader.classList.add('hidden'); }
        }

        // 5. Reset state of all cards
        function resetCardsState() {
            revealCards.forEach(card => {
                card.classList.remove('flipped', 'card-appear');
                card.style.animationDelay = '0s';
                const front = card.querySelector('.card-front');
                if (front) front.textContent = '';
            });
        }

        // 6. Reveal Multiple Cards Animation
        async function revealMultipleCards(mintedTokens) {
            if (!Array.isArray(mintedTokens)) return;
            resetCardsState();
            const cardFronts = cardContainer.querySelectorAll('.card-front');
            // Ensure we only process up to the number of card elements available
            const cardsToProcess = Math.min(mintedTokens.length, revealCards.length);

            // 1. Set card front content (hidden initially)
            for (let i = 0; i < cardsToProcess; i++) {
                 const token = mintedTokens[i];
                 const cardElement = revealCards[i];
                 const frontElement = cardFronts[i];
                 if (cardElement && frontElement) {
                    const tokenInfo = tokenMap[token.id];
                    frontElement.textContent = tokenInfo ? tokenInfo.emoji : '?';
                 }
            }

            // 2. Make container visible
            cardContainer.classList.remove('hidden');

            // 3. Trigger sequential appear and flip animations
            for (let i = 0; i < cardsToProcess; i++) {
                 if (revealCards[i]) {
                     revealCards[i].style.animationDelay = `${i * cardAppearDelay}ms`;
                     revealCards[i].classList.add('card-appear');
                 }
            }

            // Wait for appear animations to start settling
            await wait(cardsToProcess * cardAppearDelay + 100);

            for (let i = 0; i < cardsToProcess; i++) {
                 if (revealCards[i]) {
                     await wait(cardRevealDelay);
                     revealCards[i].classList.add('flipped');
                 }
            }

            // Show dismiss button after all flips are done
            await wait(cardRevealDelay); // Small extra delay
            dismissButton.classList.remove('hidden');
        }

        // 7. Dismiss Revealed Cards
        function dismissCards() {
            cardContainer.classList.add('hidden');
            dismissButton.classList.add('hidden');
            resetCardsState();
            mintResult.textContent = '';
            loadBalancesAndSupply();
        }

        // --- Initial Setup ---
        connectBtn.addEventListener("click", connectWallet);
        buyButton.addEventListener("click", buyPack);
        dismissButton.addEventListener("click", dismissCards);
        updateUI();

    </script>

</body>
</html>
